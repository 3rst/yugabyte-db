--- pgtap.sql.saf	2009-02-05 22:20:59.000000000 -0800
+++ pgtap.sql	2009-02-05 22:29:29.000000000 -0800
@@ -12,6 +12,22 @@
 -- ## CREATE SCHEMA TAPSCHEMA;
 -- ## SET search_path TO TAPSCHEMA, public;
 
+-- Cast oidvector to regtype[] like 8.1 does.
+CREATE OR REPLACE FUNCTION oidvregtype(oidvector)
+RETURNS regtype[] AS
+'SELECT COALESCE(string_to_array(textin(oidvectorout($1::oidvector)), '' '')::oid[]::regtype[], ''{}''::regtype[]);'
+LANGUAGE sql IMMUTABLE STRICT;
+
+CREATE CAST (oidvector AS regtype[]) WITH FUNCTION oidvregtype(oidvector) AS ASSIGNMENT;
+
+-- Cast int2vector to int[] like 8.1 does.
+CREATE OR REPLACE FUNCTION int2vint(int2vector)
+RETURNS int[] AS
+'SELECT COALESCE(string_to_array(textin(int2vectorout($1::int2vector)), '' '')::int[], ''{}''::int[]);'
+LANGUAGE sql IMMUTABLE STRICT;
+
+CREATE CAST (int2vector AS int[]) WITH FUNCTION int2vint(int2vector) AS ASSIGNMENT;
+
 CREATE OR REPLACE FUNCTION pg_typeof("any")
 RETURNS regtype
 AS '$libdir/pgtap'
@@ -97,53 +113,63 @@
 CREATE OR REPLACE FUNCTION _get ( text )
 RETURNS integer AS $$
 DECLARE
-    ret integer;
+    rec RECORD;
 BEGIN
-    EXECUTE 'SELECT value FROM __tcache__ WHERE label = ' || quote_literal($1) || ' LIMIT 1' INTO ret;
-    RETURN ret;
+    FOR rec IN EXECUTE 'SELECT value FROM __tcache__ WHERE label = ' || quote_literal($1) || ' LIMIT 1' LOOP
+        RETURN rec.value;
+    END LOOP;
+    RETURN NULL;
 END;
 $$ LANGUAGE plpgsql strict;
 
 CREATE OR REPLACE FUNCTION _get_latest ( text )
 RETURNS integer[] AS $$
 DECLARE
-    ret integer[];
+    rec RECORD;
 BEGIN
-    EXECUTE 'SELECT ARRAY[ id, value] FROM __tcache__ WHERE label = ' ||
+    FOR rec IN EXECUTE 'SELECT ARRAY[ id, value] AS a FROM __tcache__ WHERE label = ' ||
     quote_literal($1) || ' AND id = (SELECT MAX(id) FROM __tcache__ WHERE label = ' ||
-    quote_literal($1) || ') LIMIT 1' INTO ret;
-    RETURN ret;
+    quote_literal($1) || ') LIMIT 1' LOOP
+        RETURN rec.a;
+    END LOOP;
+    RETURN NULL;
 END;
 $$ LANGUAGE plpgsql strict;
 
 CREATE OR REPLACE FUNCTION _get_latest ( text, integer )
 RETURNS integer AS $$
 DECLARE
-    ret integer;
+    rec RECORD;
 BEGIN
-    EXECUTE 'SELECT MAX(id) FROM __tcache__ WHERE label = ' ||
-    quote_literal($1) || ' AND value = ' || $2 INTO ret;
-    RETURN ret;
+    FOR rec IN EXECUTE 'SELECT MAX(id) AS id FROM __tcache__ WHERE label = ' ||
+    quote_literal($1) || ' AND value = ' || $2 LOOP
+        RETURN rec.id;
+    END LOOP;
+    RETURN;
 END;
 $$ LANGUAGE plpgsql strict;
 
 CREATE OR REPLACE FUNCTION _get_note ( text )
 RETURNS text AS $$
 DECLARE
-    ret text;
+    rec RECORD;
 BEGIN
-    EXECUTE 'SELECT note FROM __tcache__ WHERE label = ' || quote_literal($1) || ' LIMIT 1' INTO ret;
-    RETURN ret;
+    FOR rec IN EXECUTE 'SELECT note FROM __tcache__ WHERE label = ' || quote_literal($1) || ' LIMIT 1' LOOP
+        RETURN rec.note;
+    END LOOP;
+    RETURN;
 END;
 $$ LANGUAGE plpgsql strict;
 
 CREATE OR REPLACE FUNCTION _get_note ( integer )
 RETURNS text AS $$
 DECLARE
-    ret text;
+    rec RECORD;
 BEGIN
-    EXECUTE 'SELECT note FROM __tcache__ WHERE id = ' || $1 || ' LIMIT 1' INTO ret;
-    RETURN ret;
+    FOR rec IN EXECUTE 'SELECT note FROM __tcache__ WHERE id = ' || $1 || ' LIMIT 1' LOOP
+        RETURN rec.note;
+    END LOOP;
+    RETURN;
 END;
 $$ LANGUAGE plpgsql strict;
 
@@ -207,10 +233,12 @@
 CREATE OR REPLACE FUNCTION num_failed ()
 RETURNS INTEGER AS $$
 DECLARE
-    ret integer;
+    rec RECORD;
 BEGIN
-    EXECUTE 'SELECT COUNT(*)::INTEGER FROM __tresults__ WHERE ok = FALSE' INTO ret;
-    RETURN ret;
+    FOR rec IN EXECUTE 'SELECT COUNT(*)::INTEGER AS cnt FROM __tresults__ WHERE ok = FALSE' LOOP
+        RETURN rec.cnt;
+    END LOOP;
+    RETURN;
 END;
 $$ LANGUAGE plpgsql strict;
 
@@ -484,13 +512,16 @@
     want   ALIAS FOR $3;
     descr  ALIAS FOR $4;
     result BOOLEAN;
+    rec    RECORD;
     output TEXT;
 BEGIN
-    EXECUTE 'SELECT ' ||
+    FOR rec IN EXECUTE 'SELECT ' ||
             COALESCE(quote_literal( have ), 'NULL') || '::' || pg_typeof(have) || ' '
             || op || ' ' ||
-            COALESCE(quote_literal( want ), 'NULL') || '::' || pg_typeof(want)
-       INTO result;
+            COALESCE(quote_literal( want ), 'NULL') || '::' || pg_typeof(want) || ' AS res'
+    LOOP
+        result := rec.res;
+    END LOOP;
     output := ok( COALESCE(result, FALSE), descr );
     RETURN output || CASE result WHEN TRUE THEN '' ELSE '\n' || diag(
            '    ' || COALESCE( quote_literal(have), 'NULL' ) ||
@@ -1201,19 +1232,21 @@
 CREATE OR REPLACE FUNCTION _def_is( TEXT, TEXT, anyelement, TEXT )
 RETURNS TEXT AS $$
 DECLARE
-    thing text;
+    ret RECORD;
 BEGIN
     IF $1 ~ '^[^'']+[(]' THEN
         -- It's a functional default.
         RETURN is( $1, $3, $4 );
     END IF;
 
-    EXECUTE 'SELECT is(' 
-             || COALESCE($1, 'NULL' || '::' || $2) || '::' || $2 || ', '
-             || COALESCE(quote_literal($3), 'NULL') || '::' || $2 || ', '
-             || COALESCE(quote_literal($4), 'NULL')
-    || ')' INTO thing;
-    RETURN thing;
+    FOR ret IN EXECUTE 'SELECT is(' 
+         || COALESCE($1, 'NULL' || '::' || $2) || '::' || $2 || ', '
+         || COALESCE(quote_literal($3), 'NULL') || '::' || $2 || ', '
+         || COALESCE(quote_literal($4), 'NULL')
+    || ') AS a' LOOP
+        RETURN ret.a;
+    END LOOP;
+    RETURN;
 END;
 $$ LANGUAGE plpgsql;
 
@@ -3016,6 +3049,7 @@
     res    BOOLEAN;
     descr  TEXT;
     adiag  TEXT;
+    rec    RECORD;
     have   ALIAS FOR $1;
     eok    ALIAS FOR $2;
     name   ALIAS FOR $3;
@@ -3026,8 +3060,10 @@
     tnumb := currval('__tresults___numb_seq');
 
     -- Fetch the results.
-    EXECUTE 'SELECT aok, descr FROM __tresults__ WHERE numb = ' || tnumb
-       INTO aok, adescr;
+    FOR rec IN EXECUTE 'SELECT aok, descr FROM __tresults__ WHERE numb = ' || tnumb LOOP
+        aok := rec.aok;
+        adescr := rec.descr;
+    END LOOP;
 
     -- Now delete those results.
     EXECUTE 'DELETE FROM __tresults__ WHERE numb = ' || tnumb;
@@ -3136,7 +3172,7 @@
 CREATE OR REPLACE FUNCTION _runem( text[], boolean )
 RETURNS SETOF TEXT AS $$
 DECLARE
-    tap    text;
+    rec    record;
     lbound int := array_lower($1, 1);
 BEGIN
     IF lbound IS NULL THEN RETURN; END IF;
@@ -3144,8 +3180,8 @@
         -- Send the name of the function to diag if warranted.
         IF $2 THEN RETURN NEXT diag( $1[i] || '()' ); END IF;
         -- Execute the tap function and return its results.
-        FOR tap IN EXECUTE 'SELECT * FROM ' || $1[i] || '()' LOOP
-            RETURN NEXT tap;
+        FOR rec IN EXECUTE 'SELECT * FROM ' || $1[i] || '() AS b(a)' LOOP
+            RETURN NEXT rec.a;
         END LOOP;
     END LOOP;
     RETURN;
@@ -3205,116 +3241,6 @@
 END
 $$ LANGUAGE plpgsql;
 
-CREATE OR REPLACE FUNCTION _runner( text[], text[], text[], text[], text[] )
-RETURNS SETOF TEXT AS $$
-DECLARE
-    startup  ALIAS FOR $1;
-    shutdown ALIAS FOR $2;
-    setup    ALIAS FOR $3;
-    teardown ALIAS FOR $4;
-    tests    ALIAS FOR $5;
-    tap      text;
-    verbose  boolean := _is_verbose();
-    num_faild INTEGER := 0;
-BEGIN
-    BEGIN
-        -- No plan support.
-        PERFORM * FROM no_plan();
-        FOR tap IN SELECT * FROM _runem(startup, false) LOOP RETURN NEXT tap; END LOOP;
-    EXCEPTION
-        -- Catch all exceptions and simply rethrow custom exceptions. This
-        -- will roll back everything in the above block.
-        WHEN raise_exception THEN
-            RAISE EXCEPTION '%', SQLERRM;
-    END;
-
-    BEGIN
-        FOR i IN 1..array_upper(tests, 1) LOOP
-            BEGIN
-                -- What test are we running?
-                IF verbose THEN RETURN NEXT diag(tests[i] || '()'); END IF;
-
-                -- Run the setup functions.
-                FOR tap IN SELECT * FROM _runem(setup, false) LOOP RETURN NEXT tap; END LOOP;
-
-                -- Run the actual test function.
-                FOR tap IN EXECUTE 'SELECT * FROM ' || tests[i] || '()' LOOP
-                    RETURN NEXT tap;
-                END LOOP;
-
-                -- Run the teardown functions.
-                FOR tap IN SELECT * FROM _runem(teardown, false) LOOP RETURN NEXT tap; END LOOP;
-
-                -- Remember how many failed and then roll back.
-                num_faild := num_faild + num_failed();
-                RAISE EXCEPTION '__TAP_ROLLBACK__';
-
-            EXCEPTION WHEN raise_exception THEN
-                IF SQLERRM <> '__TAP_ROLLBACK__' THEN
-                    -- We didn't raise it, so propagate it.
-                    RAISE EXCEPTION '%', SQLERRM;
-                END IF;
-            END;
-        END LOOP;
-
-        -- Run the shutdown functions.
-        FOR tap IN SELECT * FROM _runem(shutdown, false) LOOP RETURN NEXT tap; END LOOP;
-
-        -- Raise an exception to rollback any changes.
-        RAISE EXCEPTION '__TAP_ROLLBACK__';
-    EXCEPTION WHEN raise_exception THEN
-        IF SQLERRM <> '__TAP_ROLLBACK__' THEN
-            -- We didn't raise it, so propagate it.
-            RAISE EXCEPTION '%', SQLERRM;
-        END IF;
-    END;
-    -- Finish up.
-    FOR tap IN SELECT * FROM _finish( currval('__tresults___numb_seq')::integer, 0, num_faild ) LOOP
-        RETURN NEXT tap;
-    END LOOP;
-
-    -- Clean up and return.
-    PERFORM _cleanup();
-    RETURN;
-END;
-$$ LANGUAGE plpgsql;
-
--- runtests( schema, match )
-CREATE OR REPLACE FUNCTION runtests( NAME, TEXT )
-RETURNS SETOF TEXT AS $$
-    SELECT * FROM _runner(
-        findfuncs( $1, '^startup' ),
-        findfuncs( $1, '^shutdown' ),
-        findfuncs( $1, '^setup' ),
-        findfuncs( $1, '^teardown' ),
-        findfuncs( $1, $2 )
-    );
-$$ LANGUAGE sql;
-
--- runtests( schema )
-CREATE OR REPLACE FUNCTION runtests( NAME )
-RETURNS SETOF TEXT AS $$
-    SELECT * FROM runtests( $1, '^test' );
-$$ LANGUAGE sql;
-
--- runtests( match )
-CREATE OR REPLACE FUNCTION runtests( TEXT )
-RETURNS SETOF TEXT AS $$
-    SELECT * FROM _runner(
-        findfuncs( '^startup' ),
-        findfuncs( '^shutdown' ),
-        findfuncs( '^setup' ),
-        findfuncs( '^teardown' ),
-        findfuncs( $1 )
-    );
-$$ LANGUAGE sql;
-
--- runtests( )
-CREATE OR REPLACE FUNCTION runtests( )
-RETURNS SETOF TEXT AS $$
-    SELECT * FROM runtests( '^test' );
-$$ LANGUAGE sql;
-
 -- Cast booleans to text like 8.3 does.
 CREATE OR REPLACE FUNCTION booltext(boolean)
 RETURNS text AS 'SELECT CASE WHEN $1 then ''true'' ELSE ''false'' END;'
