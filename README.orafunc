Oracle functions and Oracle packages
====================================

This module contains some usefull function which can help with porting
Oracle application to PostgreSQL or can be usefull generally. Bildin
Oracle date functions was tested on conformance with Oracle10 on dates 
from interval 1960..2070 years. Dates before 1100-03-01 can't be 
verified via Oracle bug.

All functions all full compatible with Oracle and respect all known
format strings. Detailed description you can find on internet. Find
keywords oracle round trunc date iyyy.

This library don't support multibyte encoding.

List of format strings for trunc, round functions
-------------------------------------------------
Y,YY,YYY,YYYY,SYYY,SYEAR	year
I,IY,IYY,IYYY			iso year
Q,				quartal
WW				week, day as first day of year
IW				week, monday
W				week, day as first day of month
DAY,DY,D			first day of week, sunday
MONTH,MON,MM,RM			month
CC,SCC				century
DDD,DD,J			day
HH,HH12,HH24			hour
MI				minute

function round rounds up on July 1st for year, 16th day for month, 
and thursday for week.

Date Functions
==============

o add_months(date, integer) date - Returns date plus n months
	
	add_months(date '2005-05-31',1) -> 2005-06-30


o last_date(date) date - Returns last day of the month based on a date value
	
	last_day(date '2005-05-24') -> 2005-05-31


o next_day(date, text) date - Returns the first weekday that is greather than a date value
	
	next_day(date '2005-05-24', 'monday') -> 2005-05-30


o months_between(date, date) float8 - Returns the number of months between 
	date1 and date2. If a fractional month is calculated, the months_between  
	function calculates the fraction based on a 31-day month. 
	
	months_between(date '1995-02-02', date '1995-01-01') -> 1.0322580645161
	
o trunc(date, text) date - truncate date according to the specified format
	
	trunc(date '2005-07-12', 'iw') -> 2005-07-11
	
o round(date, text) date - will round dates according to the specified format

	round(date '2005-07-12', 'yyyy') -> 2006-01-01


Table dual
==========
PostgreSQL don't need oracle's table dual, but for some purposes (SELECT compatibility)
this table is usefull. Script create it.

Package dbms_output
===================
PostgreSQL send info to client via RAISE NOTICE. Oracle dbms_output.put_line works
little bit different -  Oracle has session queue, function put_line add line to 
queue, function get_line reads from queue. If flag serveroutput is set, then client
over all sql statements reads queue. You can use:

    select dbms_output.enable();
    select dbms_output.put_line('first_line');
    select dbms_output.put_line('next_line');
    select * from dbms_output.get_lines(0);
    
or
    select dbms_output.serveroutput('on');
    select dbms_output.put_line('first_line');
    
package contains functions: enable, disable, serveroutput, put, put_line, new_line,
get_line, get_lines. This package really implements line's queue in session's memory.

Package dbms_pipe
=================
This packege is emulation of Oracle's package dbms_pipe. It provides 
inter session comunication. You can send, read any message with or without 
waiting, can read system table about current pipes, can set pipe as 
private or public, can use explicit, implicit pipes. Max count of pipes is
50. For transport messages is used shared memory buffer.

-- Session A
select dbms_pipe.create_pipe('my_pipe',10,true); -- explicit pipe creating
select dbms_pipe.pack_message('neco je jinak');
select dbms_pipe.pack_message('anything is else');
select dbms_pipe.send_message('my_pipe',20,0); -- change limit and send without waiting
select * from dbms_pipe.db_pipes; -- list of current pipes

-- Session B
select dbms_pipe.receive_message('my_pipe',1); -- wait max 1 sec for message
select dbms_pipe.next_item_type(); -- -> 11, text
select dbms_pipe.unpack_message_text();
select dbms_pipe.next_item_type(); -- -> 11, text
select dbms_pipe.unpack_message_text();
select dbms_pipe.next_item_type(); -- -> 0, no more items
select dbms_pipe.remove_pipe('my_pipe');

Diff to Oracle:
  o limit for pipe isn't in bytes but in elements in pipe
  o can send message without waiting
  o cam send empty message
  o next_item_type knows TIMESTAMP -> 13
  o PostgreSQL don't know RAW format, use BYTEA

Functions:
----------


Package dbms_alert
==================
This package isn't transaction based, Oracle yes!

-- Session A
select dbms_alert.register('boo');
select * from dbms_alert.waitany(10);

-- Session B
select dbms_alert.register('boo');
select * from dbms_alert.waitany(10);

-- Session C
select dbms_alert.signal('boo','Nice day');
					
					
Package PLVdate
===============
This module contains some function for working with bussines days from
package PLVdate. Detailed documentation can be found in PLVision library.
This package is multicultural, but default configurations are only for
european countries yet (see source code).

You should define own nonbizdays (max 50 days) and own holydays (max 30 days).
Holyday is any nonbizday, which is same every year - 1. May, 24. december, ... 

o plvdate.add_bizdays(day date, days int) date - Get the date created by adding <n> business days to a date
o plvdate.nearest_bizday(day date) date -  Get the nearest business date to a given date, user defined
o plvdate.next_bizday(day date) date - Get the next business date from a given date, user defined
o plvdate.bizdays_between(day1 date, day2 date) int - Get the number of business days between two dates
o plvdate.prev_bizday(day date) date - Get the previous business date from a given date
o plvdate_isbizday(date) bool - Call this function to determine if a date is a business day

o plvdate.set_nonbizday(dow varchar) - Set day of week as non bussines day
o plvdate.unset_nonbizday(dow varchar) - Unset day of week as non bussines day
o plvdate.set_nonbizday(day date) - Set day as non bussines day
o plvdate.unset_nonbizday(day date) - Unset day as non bussines day
o plvdate.set_nonbizday(day date, repeat bool) - Set day as non bussines day, if 'repeat' is true, then day is nonbiz every year
o plvdate.unset_nonbizday(day date, repeat bool) - Unset day as non bussines day, if 'repeat' is true, then day is nonbiz every year

o plvdate.use_easter() - Easter Sunday and easter monday will be holyday
o plvdate.unuse_easter();
o plvdate.use_easter(useit boolean);
o plvdate.using_easter() bool - If we use easter then returns true
o plvdate.include_start() - Include starting date in bizdays_between calculation
o plvdate.noinclude_start();
o plvdate.include_start(include boolean);
o plvdate.including_start() bool;

o plvdate.default_holydays(varchar) - load default configurations. You can use configurations
    Czech, German*, Austria, Poland, Slovakia, Russia, GB* and  USA at this moment.

*configurations contains only common holydays for all regions. You have to add some regional holydays 
    calling function plvdate.set_nonbizday(nonbizday, true)

Example:
--------
postgres=# select plvdate.default_holydays('czech');
 default_holydays 
------------------
 
(1 row)
postgres=# select to_char(current_date, 'day'),
           plvdate.next_bizday(current_date), 
	   to_char(plvdate.next_bizday(current_date),'day');
  to_char  | next_bizday |  to_char  
-----------+-------------+-----------
 saturday  | 2006-03-13  | monday   
(1 row)

Change for noneuropean environment:
-----------------------------------
select plvdate.unset_nonbizday('saturday');
select plvdate.unset_nonbizday('sunday');
select plvdate.set_nonbizday('friday');
select plvdate.set_nonbizday('2006-05-19', true);
select plvdate.unuse_easter();

Package PLVstr and PLVchr
=========================

This package contains some usefull string, char functions. Function 
supports positive or negative (from end positioning). Example:

plvstr.left('abcdef',2) -> ab
plvstr.left('abcdef',-2) -> abcd
plvstr.substr('abcdef',1,1) -> a
plvstr.substr('abcdef',-1,1) -> f
plvstr.substr('abcde',-2,1) -> d

List of functions:
o plvstr.normalize(str text) - Normalize string - replace white chars by space, replace  spaces by space
o plvstr.is_prefix(str text, prefix text, cs bool) - Returns true, if prefix is prefix of str
o plvstr.is_prefix(str text, prefix text)          - Returns true, if prefix is prefix of str
o plvstr.is_prefix(str int, prefix int)            - Returns true, if prefix is prefix of str
o plvstr.is_prefix(str bigint, prefix bigint)      - Returns true, if prefix is prefix of str
o plvstr.substr(str text, start int, len int) - Returns substring started on start_in to end
o plvstr.substr(str text, start int)          - Returns substring started on start_in to end
o plvstr.instr(str text, patt text, start int, nth int) - Search pattern in string
o plvstr.instr(str text, patt text, start int)          - Search pattern in string
o plvstr.instr(str text, patt text)                     - Search pattern in string
o plvstr.lpart(str text, div text, start int, nth int, all_if_notfound bool) - Call this function to return the left part of a string
o plvstr.lpart(str text, div text, start int, nth int) - Call this function to return the left part of a string
o plvstr.lpart(str text, div text, start int)          - Call this function to return the left part of a string
o plvstr.lpart(str text, div text)                     - Call this function to return the left part of a string
o plvstr.rpart(str text, div text, start int, nth int, all_if_notfound bool) - Call this function to return the right part of a string
o plvstr.rpart(str text, div text, start int, nth int) - Call this function to return the right part of a string
o plvstr.rpart(str text, div text, start int)          - Call this function to return the right part of a string
o plvstr.rpart(str text, div text)                     - Call this function to return the right part of a string
o plvstr.lstrip(str text, substr text, num int) - Call this function to remove characters from the beginning 
o plvstr.lstrip(str text, substr text)          - Call this function to remove characters from the beginning 
o plvstr.rstrip(str text, substr text, num int) - Call this function to remove characters from the end
o plvstr.rstrip(str text, substr text)          - Call this function to remove characters from the end
o plvstr.rvrs(str text, start int, _end int) - Reverse string or part of string
o plvstr.rvrs(str text, start int)           - Reverse string or part of string
o plvstr.rvrs(str text)                      - Reverse string or part of string
o plvstr.left(str text, n int)  -  Returns firs num_in charaters. You can use negative num_in
o plvstr.right(str text, n int) - Returns last num_in charaters. You can use negative num_ni

o plvchr.nth(str text, n int) - Call this function to return the Nth character in a string
o plvchr.first(str text)      - Call this function to return the first character in a string
o plvchr.last(str text)       - Call this function to return the last character in a string
o plvchr.is_blank(c int)  - Is blank
o plvchr.is_blank(c text) - Is blank
o plvchr.is_digit(c int)  - Is digit 
o plvchr.is_digit(c text) - Is digit 
o plvchr.is_quote(c int)  - Is quote
o plvchr.is_quote(c text) - Is quote
o plvchr.is_other(c int)  - Is other
o plvchr.is_other(c text) - Is other
o plvchr.is_letter(c int) - Is letter
o plvchr.is_letter(c text) - Is letter
o plvchr.char_name(c text) - Returns the name of the character to ascii code as a VARCHAR.
o plvchr.quoted1(str text) - Quoted text between '''
o plvchr.quoted2(str text) - Quoted text between '"'
o plvchr.stripped(str text, char_in text) - Strips a string of all instances of the specified characters


Others functions
================
This module contains implementation of functions: concat, nvl, nvl2.

Atention! concat isn't strict function. concat('a',null) -> 'a'


ToDo:
  o support for multibyte encoding for string functions
  o better error messages
  o better documentation
  o regress tests
  o comments on functions
  o better seralization in dbms_pipe (via _send and _recv functions)

This module is released under BSD licence. 

I inwite any comments, enhancing, objectives?

Pavel Stehule
stehule@kix.fsv.cvut.cz

Prague 2006

p.s.
If use this library, please, send me mail about it.